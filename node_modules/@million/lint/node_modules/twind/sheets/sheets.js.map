{
  "version": 3,
  "sources": ["../../src/internal/dom.ts", "../../src/sheets/index.ts"],
  "sourcesContent": ["export const STYLE_ELEMENT_ID = '__twind' as const\n\ndeclare global {\n  interface Window {\n    [STYLE_ELEMENT_ID]?: HTMLStyleElement\n  }\n}\n\nexport const getStyleElement = (nonce?: string): HTMLStyleElement => {\n  // Hydrate existing style element if available\n  // self[id] - every element with an id is available through the global object\n  // eslint-disable-next-line no-restricted-globals\n  let element = self[STYLE_ELEMENT_ID]\n\n  if (!element) {\n    // Create a new one otherwise\n    element = document.head.appendChild(document.createElement('style'))\n\n    element.id = STYLE_ELEMENT_ID\n    nonce && (element.nonce = nonce)\n\n    // Avoid Edge bug where empty style elements doesn't create sheets\n    element.appendChild(document.createTextNode(''))\n  }\n\n  return element\n}\n", "/**\n * [[include:src/sheets/README.md]]\n *\n * @packageDocumentation\n * @module twind/sheets\n */\n\nimport type { SheetConfig, Sheet, SheetInit, SheetInitCallback } from 'twind'\nimport { getStyleElement, STYLE_ELEMENT_ID } from '../internal/dom'\n\n/**\n * Creates an sheet which inserts style rules through the Document Object Model.\n */\nexport const domSheet = ({\n  nonce,\n  target = getStyleElement(nonce),\n}: SheetConfig<HTMLStyleElement> = {}): Sheet<HTMLStyleElement> => {\n  const offset = target.childNodes.length\n\n  return {\n    target,\n    insert: (rule, index) =>\n      target.insertBefore(document.createTextNode(rule), target.childNodes[offset + index]),\n  }\n}\n\n/**\n * Allows to reset and snaphot the current state of an sheet and\n * in extension the internal mutable state (caches, ...) of `tw`.\n */\nexport interface Storage {\n  /**\n   * Register a function that should be called to create a new state.\n   */\n  init: SheetInit\n\n  /**\n   * Creates a snapshot of the current state, invokes all init callbacks to create a fresh state\n   * and returns the snaphot.\n   */\n  reset: (snapshot?: unknown[] | undefined) => unknown[]\n}\n\nconst createStorage = (): Storage => {\n  const callbacks: SheetInitCallback[] = []\n  let state: unknown[] = []\n\n  const invoke = <T>(callback: SheetInitCallback<T>, index: number): T =>\n    (state[index] = callback(state[index] as T))\n\n  return {\n    init: (callback) => invoke(callback, callbacks.push(callback as SheetInitCallback) - 1),\n    reset: (snapshot = []) => {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;[snapshot, state] = [state, snapshot]\n      callbacks.forEach(invoke)\n      return snapshot\n    },\n  }\n}\n\n/**\n * A sheet that collects styles into an array.\n */\nexport interface VirtualSheet extends Sheet<string[]>, Storage {\n  init: SheetInit\n}\n\n/**\n * Creates an sheet which collects style rules into an array.\n */\nexport const virtualSheet = (): VirtualSheet => {\n  const storage = createStorage()\n\n  let target: string[]\n  storage.init<string[]>((value = []) => (target = value))\n\n  return Object.defineProperties(\n    {\n      get target() {\n        return [...target]\n      },\n      insert: (rule: string, index: number) => target.splice(index, 0, rule),\n    },\n    Object.getOwnPropertyDescriptors(storage),\n  )\n}\n\nexport interface StyleTagProperties {\n  id: string\n  textContent: string\n}\n\nexport interface HasTarget {\n  readonly target: readonly string[]\n}\n\nexport type StyleTagSheet = HasTarget | readonly string[]\n\n/**\n * Transforms css rules into `<style>` tag properties.\n */\nexport const getStyleTagProperties = (sheet: StyleTagSheet): StyleTagProperties => ({\n  id: STYLE_ELEMENT_ID,\n  textContent: (Array.isArray(sheet) ? sheet : (sheet as HasTarget).target).join(''),\n})\n\n/**\n * Transforms css rules into a `<style>` tag string.\n */\nexport const getStyleTag = (sheet: StyleTagSheet, attributes?: Record<string, string>): string => {\n  const { id, textContent } = getStyleTagProperties(sheet)\n\n  attributes = { ...attributes, id }\n\n  return `<style${Object.keys(attributes).reduce(\n    (attrs, key) =>\n      `${attrs} ${key}=${JSON.stringify((attributes as Record<string, string>)[key])}`,\n    '',\n  )}>${textContent}</style>`\n}\n"],
  "mappings": ";AAAO,IAAM,mBAAmB;AAQzB,IAAM,kBAAkB,CAAC,UAAqC;AAInE,MAAI,UAAU,KAAK;AAEnB,MAAI,CAAC,SAAS;AAEZ,cAAU,SAAS,KAAK,YAAY,SAAS,cAAc;AAE3D,YAAQ,KAAK;AACb,aAAU,SAAQ,QAAQ;AAG1B,YAAQ,YAAY,SAAS,eAAe;AAAA;AAG9C,SAAO;AAAA;;;ACZF,IAAM,WAAW,CAAC;AAAA,EACvB;AAAA,EACA,SAAS,gBAAgB;AAAA,IACQ,OAAgC;AACjE,QAAM,SAAS,OAAO,WAAW;AAEjC,SAAO;AAAA,IACL;AAAA,IACA,QAAQ,CAAC,MAAM,UACb,OAAO,aAAa,SAAS,eAAe,OAAO,OAAO,WAAW,SAAS;AAAA;AAAA;AAqBpF,IAAM,gBAAgB,MAAe;AACnC,QAAM,YAAiC;AACvC,MAAI,QAAmB;AAEvB,QAAM,SAAS,CAAI,UAAgC,UAChD,MAAM,SAAS,SAAS,MAAM;AAEjC,SAAO;AAAA,IACL,MAAM,CAAC,aAAa,OAAO,UAAU,UAAU,KAAK,YAAiC;AAAA,IACrF,OAAO,CAAC,WAAW,OAAO;AAExB;AAAC,OAAC,UAAU,SAAS,CAAC,OAAO;AAC7B,gBAAU,QAAQ;AAClB,aAAO;AAAA;AAAA;AAAA;AAeN,IAAM,eAAe,MAAoB;AAC9C,QAAM,UAAU;AAEhB,MAAI;AACJ,UAAQ,KAAe,CAAC,QAAQ,OAAQ,SAAS;AAEjD,SAAO,OAAO,iBACZ;AAAA,QACM,SAAS;AACX,aAAO,CAAC,GAAG;AAAA;AAAA,IAEb,QAAQ,CAAC,MAAc,UAAkB,OAAO,OAAO,OAAO,GAAG;AAAA,KAEnE,OAAO,0BAA0B;AAAA;AAkB9B,IAAM,wBAAwB,CAAC,UAA8C;AAAA,EAClF,IAAI;AAAA,EACJ,aAAc,OAAM,QAAQ,SAAS,QAAS,MAAoB,QAAQ,KAAK;AAAA;AAM1E,IAAM,cAAc,CAAC,OAAsB,eAAgD;AAChG,QAAM,CAAE,IAAI,eAAgB,sBAAsB;AAElD,eAAa,IAAK,YAAY;AAE9B,SAAO,SAAS,OAAO,KAAK,YAAY,OACtC,CAAC,OAAO,QACN,GAAG,SAAS,OAAO,KAAK,UAAW,WAAsC,SAC3E,OACG;AAAA;",
  "names": []
}
