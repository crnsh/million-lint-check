{
  "version": 3,
  "sources": ["../../../src/shim/server/index.ts"],
  "sourcesContent": ["/* eslint-env node */\n// ^^^^ This comment is need to prevent browser bundles of this file\n\n/**\n * [[include:src/shim/server/README.md]]\n *\n * @packageDocumentation\n * @module twind/shim/server\n */\n\nimport htmlparser2Tokenizer from 'htmlparser2/lib/Tokenizer'\n\n// htmlparser2 has no esm bundle =>\n// a little dance to work around different cjs loaders\nconst Tokenizer =\n  ((htmlparser2Tokenizer as unknown) as typeof import('htmlparser2/lib/Tokenizer')).default ||\n  htmlparser2Tokenizer\n\nimport type { TW } from 'twind'\nimport { tw as defaultTW } from 'twind'\n\nexport * from 'twind'\nexport * from 'twind/sheets'\n\n/**\n * Options for {@link shim}.\n */\nexport interface ShimOptions {\n  /**\n   * Custom {@link twind.tw | tw} instance to use (default: {@link twind.tw}).\n   */\n  tw?: TW\n}\n\nconst noop = () => undefined\n\n/**\n * Shim the passed html.\n *\n * 1. tokenize the markup and process element classes with either the\n *    {@link twind.tw | default/global tw} instance or a {@link ShimOptions.tw | custom} instance\n * 2. populate the provided sheet with the generated rules\n * 3. output the HTML markup with the final element classes\n\n * @param markup the html to shim\n * @param options to use\n * @return the HTML markup with the final element classes\n */\nexport const shim = (markup: string, options: TW | ShimOptions = {}): string => {\n  const { tw = defaultTW } = typeof options == 'function' ? { tw: options } : options\n\n  let lastAttribName = ''\n  let lastChunkStart = 0\n  const chunks: string[] = []\n\n  const tokenizer = new Tokenizer(\n    {\n      decodeEntities: false,\n      xmlMode: false,\n    },\n    {\n      onattribend: noop,\n      onattribdata: (value) => {\n        if (lastAttribName == 'class') {\n          const currentIndex = tokenizer.getAbsoluteIndex()\n          const startIndex = currentIndex - value.length\n          const parsedClassNames = tw(value)\n\n          // We only need to shift things around if we need to actually change the markup\n          if (parsedClassNames !== value) {\n            // We've hit another mutation boundary\n            chunks.push(markup.slice(lastChunkStart, startIndex))\n            chunks.push(parsedClassNames)\n            lastChunkStart = currentIndex\n          }\n        }\n        // This may not be strictly necessary\n        lastAttribName = ''\n      },\n      onattribname: (name) => {\n        lastAttribName = name\n      },\n      oncdata: noop,\n      onclosetag: noop,\n      oncomment: noop,\n      ondeclaration: noop,\n      onend: noop,\n      onerror: noop,\n      onopentagend: noop,\n      onopentagname: noop,\n      onprocessinginstruction: noop,\n      onselfclosingtag: noop,\n      ontext: noop,\n    },\n  )\n\n  tokenizer.end(markup)\n\n  // Avoid unnecessary array operations and string concatenation if we never\n  // needed to slice and dice things.\n  if (!chunks.length) {\n    return markup\n  }\n\n  // Combine the current set of chunks with the tail-end of the input\n  return chunks.join('') + markup.slice(lastChunkStart || 0, markup.length)\n}\n"],
  "mappings": ";AAUA;AASA;AAEA;AACA;AARA,IAAM,YACF,qBAAgF,WAClF;AAkBF,IAAM,OAAO,MAAM;AAcZ,IAAM,OAAO,CAAC,QAAgB,UAA4B,OAAe;AAC9E,QAAM,CAAE,KAAK,aAAc,OAAO,WAAW,aAAa,CAAE,IAAI,WAAY;AAE5E,MAAI,iBAAiB;AACrB,MAAI,iBAAiB;AACrB,QAAM,SAAmB;AAEzB,QAAM,YAAY,IAAI,UACpB;AAAA,IACE,gBAAgB;AAAA,IAChB,SAAS;AAAA,KAEX;AAAA,IACE,aAAa;AAAA,IACb,cAAc,CAAC,UAAU;AACvB,UAAI,kBAAkB,SAAS;AAC7B,cAAM,eAAe,UAAU;AAC/B,cAAM,aAAa,eAAe,MAAM;AACxC,cAAM,mBAAmB,GAAG;AAG5B,YAAI,qBAAqB,OAAO;AAE9B,iBAAO,KAAK,OAAO,MAAM,gBAAgB;AACzC,iBAAO,KAAK;AACZ,2BAAiB;AAAA;AAAA;AAIrB,uBAAiB;AAAA;AAAA,IAEnB,cAAc,CAAC,SAAS;AACtB,uBAAiB;AAAA;AAAA,IAEnB,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,WAAW;AAAA,IACX,eAAe;AAAA,IACf,OAAO;AAAA,IACP,SAAS;AAAA,IACT,cAAc;AAAA,IACd,eAAe;AAAA,IACf,yBAAyB;AAAA,IACzB,kBAAkB;AAAA,IAClB,QAAQ;AAAA;AAIZ,YAAU,IAAI;AAId,MAAI,CAAC,OAAO,QAAQ;AAClB,WAAO;AAAA;AAIT,SAAO,OAAO,KAAK,MAAM,OAAO,MAAM,kBAAkB,GAAG,OAAO;AAAA;",
  "names": []
}
