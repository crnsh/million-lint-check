"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTransition = exports.startTransition = void 0;
var react_1 = require("react");
var isInputPendingSupported = "scheduling" in navigator &&
    navigator.scheduling &&
    "isInputPending" in navigator.scheduling;
var tasks = [];
var runTasks = function () {
    var _a;
    var _loop_1 = function () {
        if (isInputPendingSupported) {
            if ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending()) {
                setTimeout(runTasks);
                return { value: void 0 };
            }
            var task = tasks.shift();
            task && task();
        }
        else {
            var task_1 = tasks.shift();
            if (task_1) {
                window.requestIdleCallback(function () { return task_1(); });
            }
        }
    };
    while (tasks.length > 0) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
    }
};
// TODO: admit options
// performance.now() >= DEADLINE
exports.startTransition = function (task) {
    tasks.push(task);
    runTasks();
};
exports.useTransition = function () {
    var _a = react_1.useState(false), isPending = _a[0], setIsPending = _a[1];
    var resolver = function () { };
    var promise = new Promise(function (resolve) {
        resolver = resolve;
    });
    react_1.useEffect(function () {
        promise.then(function () {
            setIsPending(false);
        });
    });
    return [
        isPending,
        function (task) {
            setIsPending(true);
            exports.startTransition(function () {
                task();
                resolver();
            });
        },
    ];
};
